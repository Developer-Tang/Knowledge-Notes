## 公平锁

> 多个线程按照申请顺序去获取锁，需要维持一个等待队列，线程申请直接进入等待队列，锁空闲时，采取先进先出的方式维护获取锁的顺序

## 非公平锁

> 多个线程去直接尝试获取锁，获取不到进入等待队列，锁空闲时，等待队列中会采取优先级高的先获取锁，优先级低的可能一直获取不到锁

## 独享锁

> 只能被一个线程持有的锁成为独占锁，常见有 [ReentrantLock](/Java/Java基础/锁.md?id=ReentrantLock) 、 [ReadWriteLock](/Java/Java基础/锁.md?id=ReadWriteLock) 中的写锁

## 共享锁

> 能被多个线程持有的锁称为共享锁，常见有 [ReadWriteLock](/Java/Java基础/锁.md?id=ReadWriteLock) 中的读锁

## 乐观锁

> 认为获取数据时不会有其他线程更改数据，所以不上锁，但会采用版本号等机制判断数据是否改动，常见实现 [CAS](/Java/Java基础/锁.md?id=CAS)

## 悲观锁

> 认为获取数据时总会有其他线程更改数据，所以会在获取时就加锁，在释放前其他线程不能获取锁去获取/更改数据，常见实现 [synchronized](/Java/Java基础/锁.md?id=synchronized)

## 互斥锁

> 只能一个线程访问，其他线程需要等待

## 读写锁

> 读写锁分为两部分，分别为 **读锁** 和 **写锁** ，其中读锁允许多个线程同时访问，写锁只允许一个线程方法问，其他线程不能读写，获取锁时写锁优先获取。常见有 [ReadWriteLock](/Java/Java基础/锁.md?id=ReadWriteLock)

## 分段锁

> 将要操作的数据分为多段例如如数组，写时对该段进行加锁，其他段不受影响依然可以有线程方法问操作

## 可重入锁

> 一个线程已经获取锁的情况下，依然可以继续申请该锁，并且不会发生死锁，常见实现 [synchronized](/Java/Java基础/锁.md?id=synchronized) 、  [ReentrantLock](/Java/Java基础/锁.md?id=ReentrantLock)

## 无锁、偏向锁、轻量级锁、重量级锁、自旋

- **无锁：** 无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功
- **偏向锁：** 在运行过程中，对象的锁偏向某个线程。即在开启偏向锁机制的情况下，某个线程获得锁，当该线程下次再想要获得锁时，不需要再获得锁（即忽略synchronized关键词），直接就可以执行同步代码，比较适合竞争较少的情况。
- **轻量级锁：** 轻量级锁不是用来替代传统的重量级锁的，而是在没有多线程竞争的情况下，使用轻量级锁能够减少性能消耗，但是当多个线程同时竞争锁时，轻量级锁会膨胀为重量级锁。
- **重量级锁：** 即当有其他线程占用锁时，当前线程会进入阻塞状态。
- **自旋：** 当一个线程尝试去获取某一把锁的时候，如果这个锁已经被另外一个线程占有了，那么此线程就无法获取这把锁，该线程会等待，间隔一段时间后再次尝试获取。这种采用循环加锁,等待锁释放的机制就称为自旋锁

## CAS

> CAS操作包含三个操作数——内存位置(V)、预期原值(A)和新值(B)。 如果内存位置的值与预期原值相匹配，那么更新该位置的值为新值。否则，不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。

## ABA问题

> 因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A